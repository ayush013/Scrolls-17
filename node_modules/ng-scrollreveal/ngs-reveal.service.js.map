{"version":3,"file":"ngs-reveal.service.js","sourceRoot":"","sources":["../src/ngs-reveal.service.ts"],"names":[],"mappings":"OAAO,EAAE,UAAU,EAAc,MAAM,eAAe;OAC/C,EAAE,eAAe,EAAE,MAAM,qBAAqB;AAErD;;;;GAIG;AAEH;IAKE,0BAAY,MAAuB;QACjC,qDAAqD;QACrD,IAAI,QAAQ,GAA2C,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,IAAI,EAAE,CAAC,CAAC;QACvF,IAAI,CAAC,EAAE,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAC;IACnC,CAAC;IAED;;;;OAIG;IACH,iCAAM,GAAN,UAAO,UAAsB,EAAE,MAAwB;QACrD,MAAM,CAAC,UAAU,CAAC,aAAa;YAC7B,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,aAAa,EAAE,MAAM,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;IAC/D,CAAC;IAED;;;;;;OAMG;IACH,oCAAS,GAAT,UAAU,gBAA4B,EAAE,QAAgB,EAAE,QAAiB,EAAE,MAAwB;QACnG,EAAE,CAAC,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC,CAAC;YACnC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;QACpD,CAAC;QACD,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC;IACjB,CAAC;IAED;;OAEG;IACH,+BAAI,GAAJ;QACE,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC;IACjB,CAAC;IAEI,2BAAU,GAA0B;QAC3C,EAAE,IAAI,EAAE,UAAU,EAAE;KACnB,CAAC;IACF,kBAAkB;IACX,+BAAc,GAA6D;QAClF,EAAC,IAAI,EAAE,eAAe,GAAG;KACxB,CAAC;IACF,uBAAC;AAAD,CAAC,AAjDD,IAiDC","sourcesContent":["import { Injectable, ElementRef } from '@angular/core';\nimport { NgsRevealConfig } from './ngs-reveal-config';\n\n/**\n * Service to inject in directives to use ScrollReveal JS. \n * It delegates the work to SR, when DOM manipulation is possible (i.e app is not running in a web worker for e.g). \n * If not possible, most methods simply do nothing, as DOM elements are not available anyway.\n */\n\nexport class NgsRevealService {\n\n  // the Magic Maker !\n  private sr: scrollReveal.ScrollRevealObject;\n\n  constructor(config: NgsRevealConfig) {\n    // init the scrollReveal library with injected config\n    let srConfig: scrollReveal.ScrollRevealObjectOptions = Object.assign({}, config || {});\n    this.sr = ScrollReveal(srConfig);\n  }\n\n  /**\n   * Method to reveal a single DOM element.\n   * @param elementRef  a reference to the element to reveal\n   * @param config      (optional) custom configuration to use when revealing this element\n   */\n  reveal(elementRef: ElementRef, config?: NgsRevealConfig): scrollReveal.ScrollRevealObject {\n    return elementRef.nativeElement ? // can be null, if app is running in a web worker for i.e \n      this.sr.reveal(elementRef.nativeElement, config) : this.sr;\n  }\n\n  /**\n   * Method to reveal a set of DOM elements.\n   * @param parentElementRef  the parent DOM element encaspulating the child elements to reveal\n   * @param selector          a list of CSS selectors (comma-separated) that identifies child elements to reveal\n   * @param interval          (optional) interval in milliseconds, to animate child elemnts sequentially\n   * @param config            (optional) custom configuration to use when revealing this set of elements\n   */\n  revealSet(parentElementRef: ElementRef, selector: string, interval?: number, config?: NgsRevealConfig): scrollReveal.ScrollRevealObject {\n    if (parentElementRef.nativeElement) {// can be null, if app is running in a web worker for i.e \n      return this.sr.reveal(selector, config, interval);\n    }\n    return this.sr;\n  }\n\n  /**\n   * Method to synchronize and consider newly added child elements (for e.g when child elements were added asynchronously to parent DOM) .\n   */\n  sync(): void {\n    this.sr.sync();\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: ({type: any, decorators?: DecoratorInvocation[]}|null)[] = [\n{type: NgsRevealConfig, },\n];\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}